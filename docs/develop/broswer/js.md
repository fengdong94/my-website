---
id: js
title: 浏览器中的JavaScript执行机制
---

## 变量提升：JavaScript代码是按顺序执行的吗？

在编译阶段，变量和函数会被存放到变量环境中，变量的默认值会被设置为 undefined；在代码执行阶段，JavaScript 引擎会从变量环境中去查找自定义的变量和函数。

![imgs/0655d18ec347a95dfbf843969a921a13.png](imgs/0655d18ec347a95dfbf843969a921a13.png)

## 调用栈：为什么JavaScript代码会出现栈溢出？

当一段代码被执行时，JavaScript 引擎先会对其进行编译，并创建执行上下文。

- 当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。
- 当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。
- 当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。

调用栈就是用来管理函数调用关系的一种数据结构。

![imgs/ccfe41d906040031a7df1e4f1bce5837.png](imgs/ccfe41d906040031a7df1e4f1bce5837.png)

除了通过断点来查看调用栈，你还可以使用 console.trace() 来输出当前的函数调用关系。

调用栈是有大小的，当入栈的执行上下文超过一定数目，JavaScript 引擎就会报错，我们把这种错误叫做栈溢出。

## 块级作用域：var缺陷以及为什么要引入let和const？

由于 JavaScript 存在变量提升这种特性，从而导致了很多与直觉不符的代码，这也是 JavaScript 的一个重要设计缺陷。

全局作用域、函数作用域、块级作用域(ES6)

- 函数内部通过 var 声明的变量，在编译阶段全都被存放到**变量环境**里。
- 通过 let 声明的变量，在编译阶段会被存放到**词法环境**中。
- 当执行到代码块里面时，作用域块中通过 let 声明的变量，会被存放在**词法环境的一个单独的区域**中，这个区域中的变量并不影响作用域块外面的变量。
- 在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。

![imgs/06c06a756632acb12aa97b3be57bb908.png](imgs/06c06a756632acb12aa97b3be57bb908.png)

## 作用域链和闭包 ：代码中出现相同的变量，JavaScript引擎是如何选择的？

**作用域链**

在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为 outer。

**词法作用域**

词法作用域就是指作用域是由代码中函数**声明的位置**来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。**词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系。**

**查找顺序图**

![imgs/25053af5ae30c8be991fa14631cde0a7.png](imgs/25053af5ae30c8be991fa14631cde0a7.png)

**闭包**

在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。

![imgs/50e4ba60fc7e420e83b35b95e379b246.png](imgs/50e4ba60fc7e420e83b35b95e379b246.png)

如果引用闭包的函数是一个**全局变量**，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。

如果引用闭包的函数是个**局部变量**，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。

## this：从JavaScript执行上下文的视角讲清楚this

在对象内部的方法中使用对象内部的属性是一个非常普遍的需求。但是 JavaScript 的作用域机制并不支持这一点，基于这个需求，JavaScript 又搞出来另外一套 **this** 机制。

this 是和执行上下文绑定的

![imgs/b398610fd8060b381d33afc9b86f988d.png](imgs/b398610fd8060b381d33afc9b86f988d.png)

eval 执行上下文中的 this（略）

全局执行上下文中的 this — window

函数执行上下文中的 this：

三种设置 this 的方式

1. call apply bind
2. 通过对象调用方法设置
3. 通过构造函数中设置( new )
    - 创建(或者说构造)一个全新的对象。
    - 这个新对象会被执行[[原型]]连接。
    - 这个新对象会绑定到函数调用的this。
    - 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。

this 的设计缺陷以及应对方案

1. 嵌套函数中的 this 不会从外层函数中继承
    - 声明一个变量 self 用来保存 this
    - 使用 ES6 中的箭头函数(箭头函数没有自己的执行上下文)
2. 普通函数中的 this 默认指向全局对象 window
    - 严格模式 this 默认值是 undefined