---
id: skip-list
title: 跳表
---

### 如何理解“跳表”

对于一个单链表来讲，即便链表中存储的数据是有序的，要想在其中查找某个数据，也只能从头到尾遍历链表。时间复杂度 O(n)。

![imgs/46d283cd82c987153b3fe0c76dfba8a9.jpg](imgs/46d283cd82c987153b3fe0c76dfba8a9.jpg)

先查找第 k 级索引层，然后下降到下一层，依次类推就可以支持类似“二分”的查找算法。

### 用跳表查询到底有多快？

第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，那第 k 级索引结点的个数就是 n/(2^k)。

假设索引有 h 级，最高级的索引有 2 个结点。n/(2^h)=2    ⇒    h=log2(n)-1

如果包含原始链表这一层，整个跳表的高度就是 log2(n)。

我们要查找的数据是 x，在第 k 级索引中，我们遍历到 y 结点之后，发现 x 大于 y，小于后面的结点 z，所以我们通过 y 的 down 指针，从第 k 级索引下降到第 k-1 级索引。在第 k-1 级索引中，y 和 z 之间只有 3 个结点（包含 y 和 z），所以，我们在 K-1 级索引中最多只需要遍历 3 个结点，依次类推，**每一级索引都最多只需要遍历 3 个结点**。

O(3*logn) = O(logn)，时间复杂度跟二分查找是一样的。

### 跳表是不是很浪费内存？

索引的结点总和是 n/2+n/4+n/8…+8+4+2=n-2。空间复杂度是 O(n)。

如果每三个结点或五个结点，抽一个结点到上级索引，就可以减少空间复杂度。

在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了。

### 高效的动态插入和删除

插入、删除操作的时间复杂度也是 O(logn)。

### 跳表索引动态更新

当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。

当我们往跳表中插入数据的时候，我们可以选择同时将这个数据插入到部分索引层中。

通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。

### 为什么 Redis 要用跳表来实现有序集合，而不是红黑树？

Redis 中的有序集合支持的核心操作主要有下面这几个：

- 插入一个数据；
- 删除一个数据；
- 查找一个数据；
- 按照区间查找数据（比如查找值在[100, 356]之间的数据）；
- 迭代输出有序序列。

插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。

其他原因：

- 跳表更容易代码实现；
- 跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。