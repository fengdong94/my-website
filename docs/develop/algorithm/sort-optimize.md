---
id: sort-optimize
title: 排序优化
---

### 如何选择合适的排序算法？

![imgs/1f6ef7e0a5365d6e9d68f0ccc71755fd.jpg](imgs/1f6ef7e0a5365d6e9d68f0ccc71755fd.jpg)

**如果要实现一个通用的、高效率的排序函数，我们应该选择哪种排序算法？**

- 线性排序算法的时间复杂度比较低，但是适用场景比较特殊。❌
- 如果对小规模数据进行排序，可以选择时间复杂度是 O(n^2) 的算法；如果对大规模数据进行排序，时间复杂度是 O(nlogn) 的算法更加高效。❌
- 归并排序并不是原地排序算法，空间复杂度是 O(n)。❌
- 快速排序比较适合来实现排序函数，但是，快速排序在最坏情况下的时间复杂度是 O(n^2)。

### 如何优化快速排序？

O(n^2) 时间复杂度出现的主要原因还是因为分区点选得不够合理。

- **三数取中法**

我们从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。

如果要排序的数组比较大，那“三数取中”可能就不够了，可能要“五数取中”或者“十数取中”。

- **随机法**

每次从要排序的区间中，随机选择一个元素作为分区点。

这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能会出现每次分区点都选得很差的情况，所以平均情况下，这样选的分区点是比较好的。

### 举例分析排序函数

C 语言的 qsort() 会优先使用归并排序来排序输入数据，当要排序的数据量比较大的时候，qsort() 会改为用快速排序算法来排序。

qsort() 选择分区点的方法就是“三数取中法”。

qsort() 通过自己实现一个堆上的栈，手动模拟递归来解决递归太深会导致堆栈溢出的问题。

在快速排序的过程中，当要排序的区间中元素的个数小于等于 4 时，qsort() 就退化为**插入排序**，不再继续用递归来做快速排序。

```jsx
knlogn+c = 1000 * 100 * log100 + 200 远大于10000

n^2 = 100*100 = 10000
```

对于小规模数据的排序，O(n^2) 的排序算法并不一定比 O(nlogn) 排序算法执行的时间长。对于小数据量的排序，选择比较简单、不需要递归的插入排序算法。

qsort() 插入排序的算法实现中，也利用了**哨兵**来简化代码。